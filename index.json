[{"categories":["RedTeam"],"content":"360程序组件DLL劫持，可实现权限维持","date":"2025-10-20","objectID":"/posts/360dll%E5%8A%AB%E6%8C%81%E5%90%8E%E9%97%A8%E4%B8%80%E6%9E%9A/","tags":["RedTeam","权限维持"],"title":"360 DLL劫持后门一枚","uri":"/posts/360dll%E5%8A%AB%E6%8C%81%E5%90%8E%E9%97%A8%E4%B8%80%E6%9E%9A/"},{"categories":["RedTeam"],"content":"0x01 前言 进程列表里老是有这个360huabao.exe进程，然后锁屏的时候也给你弹一些很low的锁屏壁纸，很烦也很流氓。所以决定就拿它来分析一波,感觉可以用来做点什么.. 0x02 DLL劫持挖掘 ","date":"2025-10-20","objectID":"/posts/360dll%E5%8A%AB%E6%8C%81%E5%90%8E%E9%97%A8%E4%B8%80%E6%9E%9A/:0:0","tags":["RedTeam","权限维持"],"title":"360 DLL劫持后门一枚","uri":"/posts/360dll%E5%8A%AB%E6%8C%81%E5%90%8E%E9%97%A8%E4%B8%80%E6%9E%9A/"},{"categories":["RedTeam"],"content":"DLL劫持原理 老生常谈先说一波原理。应用程序加载DLL会按以下路径来搜索目标DLL进行加载，如果找不到就按下一个路径进行查找。因此，如果在这一链路中，我们可以操纵目标进程要加载的DLL，如可替换原始DLL或者高优先级路径下不存在DLL，而我们又有权限可以写入文件。这样就会导致DLL劫持。 DLL加载顺序 EXE所在目录 当前目录GetCurrentDirectory() 系统目录GetSystemDirectory() WINDOWS目录GetWindowsDirectory() 环境变量PATH所包含的目录 经测试发现exe所在路径存在未找到的DLL，且路径有权限写。可以确认存在DLL劫持。 e.g 0x03 DLL劫持利用 ","date":"2025-10-20","objectID":"/posts/360dll%E5%8A%AB%E6%8C%81%E5%90%8E%E9%97%A8%E4%B8%80%E6%9E%9A/:1:0","tags":["RedTeam","权限维持"],"title":"360 DLL劫持后门一枚","uri":"/posts/360dll%E5%8A%AB%E6%8C%81%E5%90%8E%E9%97%A8%E4%B8%80%E6%9E%9A/"},{"categories":["RedTeam"],"content":"一、劫持一次执行 查看程序的导入表，找一个导入函数最少的DLL进行劫持。 ","date":"2025-10-20","objectID":"/posts/360dll%E5%8A%AB%E6%8C%81%E5%90%8E%E9%97%A8%E4%B8%80%E6%9E%9A/:2:0","tags":["RedTeam","权限维持"],"title":"360 DLL劫持后门一枚","uri":"/posts/360dll%E5%8A%AB%E6%8C%81%E5%90%8E%E9%97%A8%E4%B8%80%E6%9E%9A/"},{"categories":["RedTeam"],"content":"无导出函数 无导出函数，执行会报错。为了保证exe能正确加载某一个DLL，我们需要在DLL编写时导出这些函数，否则会出现xxx函数找不到或者直接报错 ","date":"2025-10-20","objectID":"/posts/360dll%E5%8A%AB%E6%8C%81%E5%90%8E%E9%97%A8%E4%B8%80%E6%9E%9A/:2:1","tags":["RedTeam","权限维持"],"title":"360 DLL劫持后门一枚","uri":"/posts/360dll%E5%8A%AB%E6%8C%81%E5%90%8E%E9%97%A8%E4%B8%80%E6%9E%9A/"},{"categories":["RedTeam"],"content":"空导出函数 编写带导出函数的dll。先写一个空的导出函数看看 ，这里导出函数只是一个空函数，并没有真正的函数功能。 // dllmain.cpp : 定义 DLL 应用程序的入口点。 #include \"pch.h\" #include \u003cWindows.h\u003e // 导出函数 extern \"C\" __declspec(dllexport) void CallNtPowerInformation(){}; int Go(void) { STARTUPINFO si = {0}; PROCESS_INFORMATION pi = {0}; CreateProcess(\"c:\\\\Windows\\\\System32\\\\calc.exe\", NULL, NULL, NULL, TRUE, 0, NULL, NULL, \u0026si, \u0026pi); return 0; } BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: Go(); break; case DLL_THREAD_ATTACH: break; case DLL_THREAD_DETACH: break; case DLL_PROCESS_DETACH: break; } return TRUE; 编写好带有导出函数的dll后，将劫持DLL和目标程序放置在同一目录下，运行目标程序。劫持DLL可以正常执行。 但实际测试CS上线时发现，目标进程加载dll后，CS会立即上线但是然后又迅速退出。 e.g 经过调试，就是因为劫持DLL中的导出函数没有对应的函数功能导致的。如果目标程序用到了DLL中的函数功能，而加载的DLL中又没有，可能就会报错或直接崩掉。 代码调试，程序卸载DLL时输出调试信息 然后，这就引出了DLL函数转发的概念 ","date":"2025-10-20","objectID":"/posts/360dll%E5%8A%AB%E6%8C%81%E5%90%8E%E9%97%A8%E4%B8%80%E6%9E%9A/:2:2","tags":["RedTeam","权限维持"],"title":"360 DLL劫持后门一枚","uri":"/posts/360dll%E5%8A%AB%E6%8C%81%E5%90%8E%E9%97%A8%E4%B8%80%E6%9E%9A/"},{"categories":["RedTeam"],"content":"二、劫持 + DLL转发 原理就是先加载我们的劫持DLL，执行我们自己想要执行的操作，最后将劫持DLL中的导出函数全部重定向到程序原始的DLL中。 使用一款工具AheadLib进行转发。 1.首先找到程序使用的原始DLL 先不放置劫持DLL，启动目标程序，看程序是否在其他位置加载对应的DLL 生成DLL转发代码模板 输入DLL就是目标程序原始的DLL，然后输出的cpp文件就是函数转发后的模板代码 工具会生成一个源码模板，实际就是将DLL中所有导出函数进行转发 3.创建自己的劫持DLL 在模板代码基础上添加自己想要执行的功能代码。 4.进行DLL劫持 将目标程序要加载的原始DLL改名为生成代码模板时指定的名字 e.g 将生成的劫持dll改名为目标程序要加载的DLL名称，并将改名后的原始DLL一起放到目标程序劫持目录下。 最后执行目标程序，即可上线。也不会再掉线了。而且360huabao.exe会自动运行，还可以用来留后门。 e.g 以为数字自己的进程，进行进程注入应该不会查杀吧，然而并不是。因此，需要注意OPSEC。免杀又是后话了。 ","date":"2025-10-20","objectID":"/posts/360dll%E5%8A%AB%E6%8C%81%E5%90%8E%E9%97%A8%E4%B8%80%E6%9E%9A/:3:0","tags":["RedTeam","权限维持"],"title":"360 DLL劫持后门一枚","uri":"/posts/360dll%E5%8A%AB%E6%8C%81%E5%90%8E%E9%97%A8%E4%B8%80%E6%9E%9A/"},{"categories":["RedTeam"],"content":"Shellcode Loader，免杀360动态+进程注入+内存扫描","date":"2025-10-20","objectID":"/posts/shellcodeloader%E5%85%8D%E6%9D%80360%E5%8F%8A%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F/","tags":["RedTeam","免杀","C2"],"title":"ShellcodeLoader免杀360进程注入+内存扫描","uri":"/posts/shellcodeloader%E5%85%8D%E6%9D%80360%E5%8F%8A%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F/"},{"categories":["RedTeam"],"content":"0x01 概述 免杀Demo。实现360静动态、行为(进程注入)，及常见内存扫描Bypass。 两大痛点 动态和静态还是很容易过的，但是360环境下的进程注入，还有高度防护环境下的内存扫描，如果不注意还是很容易被检测到的。 免杀效果 0x02 行为查杀Bypass 360的行为查杀 (进程注入) 还是很大的痛点，CS后渗透任务常用命令基本都依赖fork\u0026run，起一个子进程然后注入。而360对进程注入杀的特别死，基于白名单机制，只要不是白名单进程就会告警。所以Bypass方案就变成了上线为白名单进程即可Bypass，而notepad就是白名单进程。 经过测试，远程线程劫持可以实现上线到白名单进程，且不会被查杀。 0x03 内存扫描Bypass 针对的内存扫描工具： BeaconEye Hunt-Sleeping-Beacons pe-sieve moneta MalMemDetect Yara 主要思路包括：CS自带的内存规避相关机制，静态特征修改、变异的sleepmask、beacon patch、开源UDRL。 ","date":"2025-10-20","objectID":"/posts/shellcodeloader%E5%85%8D%E6%9D%80360%E5%8F%8A%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F/:0:0","tags":["RedTeam","免杀","C2"],"title":"ShellcodeLoader免杀360进程注入+内存扫描","uri":"/posts/shellcodeloader%E5%85%8D%E6%9D%80360%E5%8F%8A%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F/"},{"categories":["RedTeam"],"content":"一、模式匹配Bypass ","date":"2025-10-20","objectID":"/posts/shellcodeloader%E5%85%8D%E6%9D%80360%E5%8F%8A%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F/:1:0","tags":["RedTeam","免杀","C2"],"title":"ShellcodeLoader免杀360进程注入+内存扫描","uri":"/posts/shellcodeloader%E5%85%8D%E6%9D%80360%E5%8F%8A%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F/"},{"categories":["RedTeam"],"content":"1. Yara Malleable C2进行特征替换 ","date":"2025-10-20","objectID":"/posts/shellcodeloader%E5%85%8D%E6%9D%80360%E5%8F%8A%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F/:1:1","tags":["RedTeam","免杀","C2"],"title":"ShellcodeLoader免杀360进程注入+内存扫描","uri":"/posts/shellcodeloader%E5%85%8D%E6%9D%80360%E5%8F%8A%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F/"},{"categories":["RedTeam"],"content":"2. BeaconEye 使用的开源UDRL，Beacon休眠时可以过BeaconEye，但执行post-ex任务还是会被检测。 BeaconEye Bypass方法用的是网上常用的Gap字节填充，对beacon.dll进行Patch e.g ","date":"2025-10-20","objectID":"/posts/shellcodeloader%E5%85%8D%E6%9D%80360%E5%8F%8A%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F/:1:2","tags":["RedTeam","免杀","C2"],"title":"ShellcodeLoader免杀360进程注入+内存扫描","uri":"/posts/shellcodeloader%E5%85%8D%E6%9D%80360%E5%8F%8A%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F/"},{"categories":["RedTeam"],"content":"二、异常内存属性检测Bypass 使用开源UDRL，原理深入学习中 项目地址：https://github.com/kyleavery/AceLdr e.g ","date":"2025-10-20","objectID":"/posts/shellcodeloader%E5%85%8D%E6%9D%80360%E5%8F%8A%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F/:2:0","tags":["RedTeam","免杀","C2"],"title":"ShellcodeLoader免杀360进程注入+内存扫描","uri":"/posts/shellcodeloader%E5%85%8D%E6%9D%80360%E5%8F%8A%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"About Me","date":"2025-10-01","objectID":"/about/","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"关于博客 个人博客，链接社区 分享和交流很重要 ","date":"2025-10-01","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"About Me 💻 红队选手、安全爱好者, 向往成为独立安全研究员 🛠️ 热衷于探索底层原理 🏔️ 爱好户外、摄影, 技术宅\u0026户外野驴并存 💪 空杯心态，一直在路上 ","date":"2025-10-01","objectID":"/about/:2:0","tags":null,"title":"","uri":"/about/"}]